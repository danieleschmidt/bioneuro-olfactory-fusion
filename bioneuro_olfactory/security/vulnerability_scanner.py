"""
Automated vulnerability scanning for neuromorphic gas detection system.
Scans for security vulnerabilities, misconfigurations, and potential threats.
"""

import os
import re
import ast
import json
import logging
import subprocess
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
import hashlib
import requests
from pathlib import Path

logger = logging.getLogger(__name__)


class VulnerabilityLevel(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""
    vuln_id: str
    title: str
    description: str
    severity: VulnerabilityLevel
    category: str
    file_path: Optional[str]
    line_number: Optional[int]
    code_snippet: Optional[str]
    recommendation: str
    cve_references: List[str]
    confidence: float
    discovered_at: datetime


@dataclass
class ScanResult:
    """Results of vulnerability scan."""
    scan_id: str
    scan_type: str
    start_time: datetime
    end_time: datetime
    vulnerabilities: List[Vulnerability]
    summary: Dict[str, int]
    scanned_files: int
    total_lines: int


class CodeSecurityScanner:
    """Scans source code for security vulnerabilities."""
    
    def __init__(self):
        self.security_patterns = self._load_security_patterns()
        self.dangerous_functions = self._load_dangerous_functions()
        
    def scan_directory(self, directory: str) -> List[Vulnerability]:
        """Scan directory for security vulnerabilities."""
        vulnerabilities = []
        
        for file_path in self._get_python_files(directory):
            file_vulns = self.scan_file(file_path)
            vulnerabilities.extend(file_vulns)
            
        return vulnerabilities
        
    def scan_file(self, file_path: str) -> List[Vulnerability]:
        """Scan a single file for vulnerabilities."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Static analysis
            vulnerabilities.extend(self._scan_static_patterns(file_path, content))
            vulnerabilities.extend(self._scan_ast_patterns(file_path, content))
            vulnerabilities.extend(self._scan_hardcoded_secrets(file_path, content))
            
        except Exception as e:
            logger.error(f"Error scanning file {file_path}: {e}")
            
        return vulnerabilities
        
    def _scan_static_patterns(self, file_path: str, content: str) -> List[Vulnerability]:
        """Scan for static security patterns."""
        vulnerabilities = []
        lines = content.split('\n')
        
        for pattern_name, pattern_data in self.security_patterns.items():
            regex = pattern_data['regex']
            severity = VulnerabilityLevel(pattern_data['severity'])
            description = pattern_data['description']
            recommendation = pattern_data['recommendation']
            
            for line_num, line in enumerate(lines, 1):
                if re.search(regex, line, re.IGNORECASE):
                    vuln = Vulnerability(
                        vuln_id=f"STATIC_{hashlib.md5(f'{file_path}:{line_num}:{pattern_name}'.encode()).hexdigest()[:8]}",
                        title=f"Security Pattern: {pattern_name}",
                        description=description,
                        severity=severity,
                        category="code_security",
                        file_path=file_path,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation=recommendation,
                        cve_references=[],
                        confidence=0.8,
                        discovered_at=datetime.utcnow()
                    )
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities
        
    def _scan_ast_patterns(self, file_path: str, content: str) -> List[Vulnerability]:
        """Scan using AST analysis."""
        vulnerabilities = []
        
        try:
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    vuln = self._check_dangerous_function_call(file_path, node, content)
                    if vuln:
                        vulnerabilities.append(vuln)
                        
                elif isinstance(node, ast.Import):
                    vuln = self._check_dangerous_import(file_path, node)
                    if vuln:
                        vulnerabilities.append(vuln)
                        
        except SyntaxError as e:
            logger.warning(f"Syntax error in {file_path}: {e}")
            
        return vulnerabilities
        
    def _scan_hardcoded_secrets(self, file_path: str, content: str) -> List[Vulnerability]:
        """Scan for hardcoded secrets and credentials."""
        vulnerabilities = []
        
        secret_patterns = {
            'api_key': r'(?i)api[_-]?key\s*[=:]\s*["\']([a-zA-Z0-9]{20,})["\']',
            'password': r'(?i)password\s*[=:]\s*["\']([^"\']{8,})["\']',
            'secret_key': r'(?i)secret[_-]?key\s*[=:]\s*["\']([a-zA-Z0-9]{20,})["\']',
            'private_key': r'-----BEGIN PRIVATE KEY-----',
            'aws_access_key': r'AKIA[0-9A-Z]{16}',
            'jwt_secret': r'(?i)jwt[_-]?secret\s*[=:]\s*["\']([a-zA-Z0-9]{20,})["\']'
        }
        
        lines = content.split('\n')
        
        for secret_type, pattern in secret_patterns.items():
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line):
                    vuln = Vulnerability(
                        vuln_id=f"SECRET_{hashlib.md5(f'{file_path}:{line_num}:{secret_type}'.encode()).hexdigest()[:8]}",
                        title=f"Hardcoded Secret: {secret_type}",
                        description=f"Hardcoded {secret_type} found in source code",
                        severity=VulnerabilityLevel.HIGH,
                        category="secrets",
                        file_path=file_path,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation=f"Move {secret_type} to environment variables or secure configuration",
                        cve_references=[],
                        confidence=0.9,
                        discovered_at=datetime.utcnow()
                    )
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities
        
    def _check_dangerous_function_call(self, file_path: str, node: ast.Call, content: str) -> Optional[Vulnerability]:
        """Check for dangerous function calls."""
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
        elif isinstance(node.func, ast.Attribute):
            func_name = node.func.attr
        else:
            return None
            
        if func_name in self.dangerous_functions:
            func_data = self.dangerous_functions[func_name]
            
            return Vulnerability(
                vuln_id=f"FUNC_{hashlib.md5(f'{file_path}:{node.lineno}:{func_name}'.encode()).hexdigest()[:8]}",
                title=f"Dangerous Function: {func_name}",
                description=func_data['description'],
                severity=VulnerabilityLevel(func_data['severity']),
                category="dangerous_functions",
                file_path=file_path,
                line_number=node.lineno,
                code_snippet=self._get_line_from_content(content, node.lineno),
                recommendation=func_data['recommendation'],
                cve_references=[],
                confidence=0.7,
                discovered_at=datetime.utcnow()
            )
            
        return None
        
    def _check_dangerous_import(self, file_path: str, node: ast.Import) -> Optional[Vulnerability]:
        """Check for dangerous imports."""
        dangerous_modules = {
            'pickle': 'Pickle module can execute arbitrary code during deserialization',
            'eval': 'Eval function can execute arbitrary code',
            'exec': 'Exec function can execute arbitrary code'
        }
        
        for alias in node.names:
            if alias.name in dangerous_modules:
                return Vulnerability(
                    vuln_id=f"IMPORT_{hashlib.md5(f'{file_path}:{node.lineno}:{alias.name}'.encode()).hexdigest()[:8]}",
                    title=f"Dangerous Import: {alias.name}",
                    description=dangerous_modules[alias.name],
                    severity=VulnerabilityLevel.MEDIUM,
                    category="dangerous_imports",
                    file_path=file_path,
                    line_number=node.lineno,
                    code_snippet=f"import {alias.name}",
                    recommendation=f"Avoid using {alias.name} or ensure proper input validation",
                    cve_references=[],
                    confidence=0.6,
                    discovered_at=datetime.utcnow()
                )
                
        return None
        
    def _get_python_files(self, directory: str) -> List[str]:
        """Get all Python files in directory."""
        python_files = []
        for root, dirs, files in os.walk(directory):
            # Skip hidden directories and common excludes
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules']]
            
            for file in files:
                if file.endswith('.py'):
                    python_files.append(os.path.join(root, file))
                    
        return python_files
        
    def _get_line_from_content(self, content: str, line_number: int) -> str:
        """Get specific line from content."""
        lines = content.split('\n')
        if 1 <= line_number <= len(lines):
            return lines[line_number - 1].strip()
        return ""
        
    def _load_security_patterns(self) -> Dict[str, Dict]:
        """Load security pattern definitions."""
        return {
            'sql_injection': {
                'regex': r'(?i)(execute|query)\s*\(\s*["\'].*\+.*["\']',
                'severity': 'high',
                'description': 'Potential SQL injection vulnerability',
                'recommendation': 'Use parameterized queries or ORM'
            },
            'command_injection': {
                'regex': r'(?i)(os\.system|subprocess\.call|subprocess\.run)\s*\([^)]*\+',
                'severity': 'critical',
                'description': 'Potential command injection vulnerability',
                'recommendation': 'Sanitize input and use safe subprocess methods'
            },
            'path_traversal': {
                'regex': r'open\s*\([^)]*\.\./[^)]*\)',
                'severity': 'high',
                'description': 'Potential path traversal vulnerability',
                'recommendation': 'Validate and sanitize file paths'
            },
            'weak_random': {
                'regex': r'(?i)random\.(random|randint|choice)',
                'severity': 'medium',
                'description': 'Use of weak random number generator',
                'recommendation': 'Use secrets module for cryptographic randomness'
            },
            'debug_mode': {
                'regex': r'(?i)debug\s*=\s*True',
                'severity': 'medium',
                'description': 'Debug mode enabled',
                'recommendation': 'Disable debug mode in production'
            }
        }
        
    def _load_dangerous_functions(self) -> Dict[str, Dict]:
        """Load dangerous function definitions."""
        return {
            'eval': {
                'description': 'eval() can execute arbitrary code',
                'severity': 'critical',
                'recommendation': 'Avoid eval() or use ast.literal_eval() for safe evaluation'
            },
            'exec': {
                'description': 'exec() can execute arbitrary code',
                'severity': 'critical',
                'recommendation': 'Avoid exec() or implement strict input validation'
            },
            'compile': {
                'description': 'compile() can create code objects',
                'severity': 'high',
                'recommendation': 'Avoid compile() with untrusted input'
            },
            '__import__': {
                'description': '__import__() can import arbitrary modules',
                'severity': 'high',
                'recommendation': 'Use importlib with proper validation'
            }
        }


class DependencyScanner:
    """Scans dependencies for known vulnerabilities."""
    
    def __init__(self):
        self.vulnerability_db = self._load_vulnerability_db()
        
    def scan_requirements(self, requirements_file: str) -> List[Vulnerability]:
        """Scan requirements file for vulnerable dependencies."""
        vulnerabilities = []
        
        if not os.path.exists(requirements_file):
            logger.warning(f"Requirements file not found: {requirements_file}")
            return vulnerabilities
            
        try:
            with open(requirements_file, 'r') as f:
                requirements = f.read()
                
            dependencies = self._parse_requirements(requirements)
            
            for dep_name, version in dependencies.items():
                vulns = self._check_dependency_vulnerabilities(dep_name, version)
                vulnerabilities.extend(vulns)
                
        except Exception as e:
            logger.error(f"Error scanning requirements: {e}")
            
        return vulnerabilities
        
    def _parse_requirements(self, requirements: str) -> Dict[str, str]:
        """Parse requirements file."""
        dependencies = {}
        
        for line in requirements.split('\n'):
            line = line.strip()
            if line and not line.startswith('#'):
                # Simple parsing - could be improved
                if '==' in line:
                    name, version = line.split('==', 1)
                    dependencies[name.strip()] = version.strip()
                elif '>=' in line:
                    name, version = line.split('>=', 1)
                    dependencies[name.strip()] = version.strip()
                    
        return dependencies
        
    def _check_dependency_vulnerabilities(self, package: str, version: str) -> List[Vulnerability]:
        """Check if dependency has known vulnerabilities."""
        vulnerabilities = []
        
        package_vulns = self.vulnerability_db.get(package.lower(), [])
        
        for vuln_data in package_vulns:
            affected_versions = vuln_data.get('affected_versions', [])
            
            if self._version_affected(version, affected_versions):
                vuln = Vulnerability(
                    vuln_id=vuln_data['cve'],
                    title=f"Vulnerable Dependency: {package}",
                    description=vuln_data['description'],
                    severity=VulnerabilityLevel(vuln_data['severity']),
                    category="dependency",
                    file_path="requirements.txt",
                    line_number=None,
                    code_snippet=f"{package}=={version}",
                    recommendation=f"Update {package} to version {vuln_data.get('fixed_version', 'latest')}",
                    cve_references=[vuln_data['cve']],
                    confidence=0.95,
                    discovered_at=datetime.utcnow()
                )
                vulnerabilities.append(vuln)
                
        return vulnerabilities
        
    def _version_affected(self, version: str, affected_versions: List[str]) -> bool:
        """Check if version is affected by vulnerability."""
        # Simplified version comparison
        for affected in affected_versions:
            if version == affected or version.startswith(affected):
                return True
        return False
        
    def _load_vulnerability_db(self) -> Dict[str, List[Dict]]:
        """Load vulnerability database."""
        # In a real implementation, this would load from a CVE database
        return {
            'django': [
                {
                    'cve': 'CVE-2023-1234',
                    'description': 'SQL injection vulnerability in Django ORM',
                    'severity': 'high',
                    'affected_versions': ['3.0', '3.1', '3.2'],
                    'fixed_version': '3.2.1'
                }
            ],
            'flask': [
                {
                    'cve': 'CVE-2023-5678',
                    'description': 'XSS vulnerability in Flask template engine',
                    'severity': 'medium',
                    'affected_versions': ['1.0', '1.1'],
                    'fixed_version': '1.1.1'
                }
            ]
        }


class ConfigurationScanner:
    """Scans configuration for security issues."""
    
    def scan_configurations(self, config_dir: str) -> List[Vulnerability]:
        """Scan configuration files for security issues."""
        vulnerabilities = []
        
        config_files = self._find_config_files(config_dir)
        
        for config_file in config_files:
            file_vulns = self._scan_config_file(config_file)
            vulnerabilities.extend(file_vulns)
            
        return vulnerabilities
        
    def _find_config_files(self, directory: str) -> List[str]:
        """Find configuration files."""
        config_extensions = ['.yml', '.yaml', '.json', '.toml', '.ini', '.conf']
        config_files = []
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                if any(file.endswith(ext) for ext in config_extensions):
                    config_files.append(os.path.join(root, file))
                    
        return config_files
        
    def _scan_config_file(self, file_path: str) -> List[Vulnerability]:
        """Scan individual configuration file."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                
            # Check for common security issues
            vulnerabilities.extend(self._check_weak_passwords(file_path, content))
            vulnerabilities.extend(self._check_insecure_protocols(file_path, content))
            vulnerabilities.extend(self._check_debug_settings(file_path, content))
            
        except Exception as e:
            logger.error(f"Error scanning config file {file_path}: {e}")
            
        return vulnerabilities
        
    def _check_weak_passwords(self, file_path: str, content: str) -> List[Vulnerability]:
        """Check for weak passwords in configuration."""
        vulnerabilities = []
        
        weak_patterns = [
            r'password\s*[:=]\s*["\']?(admin|password|123456|secret)["\']?',
            r'passwd\s*[:=]\s*["\']?(admin|password|123456|secret)["\']?'
        ]
        
        lines = content.split('\n')
        
        for pattern in weak_patterns:
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line, re.IGNORECASE):
                    vuln = Vulnerability(
                        vuln_id=f"CONFIG_{hashlib.md5(f'{file_path}:{line_num}'.encode()).hexdigest()[:8]}",
                        title="Weak Password in Configuration",
                        description="Weak or default password found in configuration",
                        severity=VulnerabilityLevel.HIGH,
                        category="configuration",
                        file_path=file_path,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Use strong, unique passwords and store them securely",
                        cve_references=[],
                        confidence=0.8,
                        discovered_at=datetime.utcnow()
                    )
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities
        
    def _check_insecure_protocols(self, file_path: str, content: str) -> List[Vulnerability]:
        """Check for insecure protocol configurations."""
        vulnerabilities = []
        
        insecure_patterns = [
            r'(?i)ssl\s*[:=]\s*false',
            r'(?i)tls\s*[:=]\s*false',
            r'(?i)http://',
            r'(?i)ftp://'
        ]
        
        lines = content.split('\n')
        
        for pattern in insecure_patterns:
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line):
                    vuln = Vulnerability(
                        vuln_id=f"PROTO_{hashlib.md5(f'{file_path}:{line_num}'.encode()).hexdigest()[:8]}",
                        title="Insecure Protocol Configuration",
                        description="Insecure protocol or disabled encryption found",
                        severity=VulnerabilityLevel.MEDIUM,
                        category="configuration",
                        file_path=file_path,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Enable SSL/TLS encryption and use secure protocols",
                        cve_references=[],
                        confidence=0.7,
                        discovered_at=datetime.utcnow()
                    )
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities
        
    def _check_debug_settings(self, file_path: str, content: str) -> List[Vulnerability]:
        """Check for debug settings in production."""
        vulnerabilities = []
        
        debug_patterns = [
            r'(?i)debug\s*[:=]\s*true',
            r'(?i)verbose\s*[:=]\s*true',
            r'(?i)log_level\s*[:=]\s*["\']?(debug|trace)["\']?'
        ]
        
        lines = content.split('\n')
        
        for pattern in debug_patterns:
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line):
                    vuln = Vulnerability(
                        vuln_id=f"DEBUG_{hashlib.md5(f'{file_path}:{line_num}'.encode()).hexdigest()[:8]}",
                        title="Debug Mode Enabled",
                        description="Debug mode or verbose logging enabled",
                        severity=VulnerabilityLevel.LOW,
                        category="configuration",
                        file_path=file_path,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Disable debug mode and verbose logging in production",
                        cve_references=[],
                        confidence=0.6,
                        discovered_at=datetime.utcnow()
                    )
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities


class VulnerabilityScanner:
    """Main vulnerability scanner coordinating all scan types."""
    
    def __init__(self):
        self.code_scanner = CodeSecurityScanner()
        self.dependency_scanner = DependencyScanner()
        self.config_scanner = ConfigurationScanner()
        
    def comprehensive_scan(self, project_dir: str) -> ScanResult:
        """Perform comprehensive security scan."""
        scan_id = hashlib.md5(f"{project_dir}:{datetime.utcnow()}".encode()).hexdigest()[:12]
        start_time = datetime.utcnow()
        
        logger.info(f"Starting comprehensive security scan (ID: {scan_id})")
        
        all_vulnerabilities = []
        scanned_files = 0
        total_lines = 0
        
        # Code security scan
        logger.info("Scanning source code for security vulnerabilities...")
        code_vulns = self.code_scanner.scan_directory(project_dir)
        all_vulnerabilities.extend(code_vulns)
        
        # Dependency scan
        logger.info("Scanning dependencies for known vulnerabilities...")
        requirements_files = [
            os.path.join(project_dir, 'requirements.txt'),
            os.path.join(project_dir, 'requirements-dev.txt'),
            os.path.join(project_dir, 'pyproject.toml')
        ]
        
        for req_file in requirements_files:
            if os.path.exists(req_file):
                dep_vulns = self.dependency_scanner.scan_requirements(req_file)
                all_vulnerabilities.extend(dep_vulns)
                
        # Configuration scan
        logger.info("Scanning configuration files...")
        config_vulns = self.config_scanner.scan_configurations(project_dir)
        all_vulnerabilities.extend(config_vulns)
        
        # Count files and lines
        for root, dirs, files in os.walk(project_dir):
            for file in files:
                if file.endswith('.py'):
                    scanned_files += 1
                    try:
                        with open(os.path.join(root, file), 'r') as f:
                            total_lines += len(f.readlines())
                    except:
                        pass
                        
        end_time = datetime.utcnow()
        
        # Create summary
        summary = {
            'total': len(all_vulnerabilities),
            'critical': len([v for v in all_vulnerabilities if v.severity == VulnerabilityLevel.CRITICAL]),
            'high': len([v for v in all_vulnerabilities if v.severity == VulnerabilityLevel.HIGH]),
            'medium': len([v for v in all_vulnerabilities if v.severity == VulnerabilityLevel.MEDIUM]),
            'low': len([v for v in all_vulnerabilities if v.severity == VulnerabilityLevel.LOW]),
            'info': len([v for v in all_vulnerabilities if v.severity == VulnerabilityLevel.INFO])
        }
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type="comprehensive",
            start_time=start_time,
            end_time=end_time,
            vulnerabilities=all_vulnerabilities,
            summary=summary,
            scanned_files=scanned_files,
            total_lines=total_lines
        )
        
        logger.info(f"Security scan completed. Found {summary['total']} vulnerabilities "
                   f"({summary['critical']} critical, {summary['high']} high)")
        
        return scan_result
        
    def generate_report(self, scan_result: ScanResult, output_file: str = None) -> str:
        """Generate vulnerability report."""
        report = {
            'scan_metadata': {
                'scan_id': scan_result.scan_id,
                'scan_type': scan_result.scan_type,
                'start_time': scan_result.start_time.isoformat(),
                'end_time': scan_result.end_time.isoformat(),
                'duration_seconds': (scan_result.end_time - scan_result.start_time).total_seconds(),
                'scanned_files': scan_result.scanned_files,
                'total_lines': scan_result.total_lines
            },
            'summary': scan_result.summary,
            'vulnerabilities': [asdict(vuln) for vuln in scan_result.vulnerabilities]
        }
        
        # Convert datetime objects to strings
        for vuln in report['vulnerabilities']:
            vuln['discovered_at'] = vuln['discovered_at'].isoformat()
            vuln['severity'] = vuln['severity'].value
            
        report_json = json.dumps(report, indent=2, default=str)
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(report_json)
            logger.info(f"Vulnerability report saved to {output_file}")
            
        return report_json


# Global scanner instance
vulnerability_scanner = VulnerabilityScanner()